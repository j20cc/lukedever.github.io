---
title: 动态规划入门学习笔记
date: 2021-03-02 17:02:47
categories:
- 算法
tags:
- 动态规划
---

## 什么是动态规划

动态规划（英语：Dynamic programming，简称 DP）是一种在数学、管理科学、计算机科学、经济学和生物信息学中使用的，通过把原问题分解为相对简单的子问题的方式求解复杂问题的方法。

动态规划常常适用于有 **重叠子问题** 和 **最优子结构性质** 的问题，动态规划方法所耗时间往往远少于朴素解法。

-- 摘自 leetcode

## 什么题目适合使用动态规划来解

1. 求最值
2. 计数
3. 是否存在

大概率可以用动态规划来做

## 一般步骤

1. 确定状态

2. 写出转移方程

3. 初始条件和边界

4. 计算顺序

## 例题

- 有面值为 2、5、7 无限多枚的硬币，问组成面值 27 最少需要多少枚？

假设最少需要 k 枚, a1+a2+a3+...+ak=27, f(27) = k

最后一枚面值是 ak, 所以组成面值 27-ak 最少需要 k-1 枚, f(27-ak) = k-1

而最后一枚只可能是 2/5/7，总的最少枚数应该是这三种情况的最小值

写出方程，对于要组成任意 x 的面值 f(x) = min{f(x-2)+1, f(x-5)+1, f(x-7)+1}

已知，初始条件 f(0) = 0，如果能知道 f(1) f(2) .. f(20) f(21) f(22) ...的值，就能轻松算出 f(27) 来，所以如果能从前往后把结果先算出来，到 27 时就可以迅速得到答案

以下是代码:

```go
func coinChange(coins []int, m int) int {
    //开辟一个27大小的整形切片
	dp := make([]int, m+1)
    //已知组成0的面值需要0枚
	dp[0] = 0

	n := len(coins)
    //从面值1开始往27计算
	for i := 1; i <= m; i++ {
        //初始为最大值，后面更新最小值
		dp[i] = math.MaxInt64
        //遍历每种硬币的情况
		for j := 0; j < n; j++ {
            //注意边界
			if i >= coins[j] && dp[i-coins[j]] != math.MaxInt64 {
				dp[i] = min(dp[i-coins[j]]+1, dp[i])
			}
		}
	}

	if dp[m] == math.MaxInt64 {
		dp[m] = -1
	}

	return dp[m]
}

func min(a, b int) int {
	if a >= b {
		return b
	}
	return a
}
```