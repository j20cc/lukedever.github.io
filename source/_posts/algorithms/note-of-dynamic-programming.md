---
title: 通过换硬币例题来入门动态规划
date: 2021-03-25 17:02:47
categories:
- 算法
tags:
- 动态规划
---

## 什么是动态规划

动态规划（英语：Dynamic programming，简称 DP）是一种在数学、管理科学、计算机科学、经济学和生物信息学中使用的，通过把原问题分解为相对简单的子问题的方式求解复杂问题的方法。

动态规划常常适用于有 **重叠子问题** 和 **最优子结构性质** 的问题，动态规划方法所耗时间往往远少于朴素解法。

-- 摘自 leetcode

## 什么题目适合使用动态规划来解

1. 求最值
2. 计数
3. 是否存在

**大概率**可以用动态规划来做

## 一般步骤

1. 确定状态

2. 写出转移方程

3. 初始条件和边界

4. 计算顺序

## 例题

- 有面值为 2、5、7 无限多枚的硬币，问组成面值 27 最少需要多少枚？

假设最少需要 k 枚, a1+a2+a3+...+ak=27, f(27) = k

最后一枚面值是 ak, 所以组成面值 27-ak 最少需要 k-1 枚, f(27-ak) = k-1

而最后一枚只可能是 2/5/7，总的最少枚数应该是这三种情况的最小值

写出方程，对于要组成任意 x 的面值 f(x) = min{f(x-2)+1, f(x-5)+1, f(x-7)+1}

已知，初始条件 f(0) = 0，如果能知道 f(1) f(2) .. f(20) f(21) f(22) ...的值，就能轻松算出 f(27) 来，所以如果能从前往后把结果先算出来，到 27 时就可以迅速得到答案

以下是代码:

```go
func coinChange(coins []int, m int) int {
    //开辟一个27大小的整形切片
    dp := make([]int, m+1)
    //已知组成0的面值需要0枚
    dp[0] = 0

    n := len(coins)
    //从面值1开始往27计算
    for i := 1; i <= m; i++ {
        //初始为最大值，后面更新最小值
        dp[i] = math.MaxInt64
        //遍历每种硬币的情况
        for j := 0; j < n; j++ {
            //注意边界
            if i >= coins[j] && dp[i-coins[j]] != math.MaxInt64 {
                dp[i] = min(dp[i-coins[j]]+1, dp[i])
            }
        }
    }

    if dp[m] == math.MaxInt64 {
        dp[m] = -1
    }

    return dp[m]
}

func min(a, b int) int {
    if a >= b {
        return b
    }
    return a
}
```